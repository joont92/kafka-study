# 컨슈머 주요 옵션

#### bootstrap.severs
프로듀서와 동일하다

#### fetch.min.bytes, fetch.max.bytes
한번에 가져올 수 있는 최소/최대 데이터 사이즈이다  
가져올 데이터가 fetch.min.bytes 보다 작을 경우 데이터가 누적될 때 까지 기다린다

#### group.id
컨슈머가 속한 그룹을 식별하는 식별자이다(consumer group)

#### enable.auto.commit
백그라운드로 주기적으로 오프셋을 커밋한다

#### auto.offset.reset
컨슈머에서 요청한 오프셋이 존재하지 않을 경우 지정한 옵션에 맞게 행동한다
- earliest : 가장 초기의 오프셋으로 설정
- latest : 가장 마지막 오프셋으로 설정
- none : 에러 발생

#### session.timeout.ms
브로커에서 컨슈머가 살아있다고 판단하는 시간이다(기본값 10초)  
브로커에서 이 시간이 지날때까지 컨슈머의 poll 요청(실제 poll + heartbeat)이 오지 않는다면, 브로커는 해당 컨슈머가 종료되었거나 장애가 발생한 것으로 판단하고 컨슈머 그룹의 리밸런스를 시도한다  

이 시간을 짧게 설정하면 컨슈머의 실패를 빨리 감지할 수 있지만, 컨슈머의 로직(가비지 컬렉션, 루프 등) 완료하는 시간이 길어지게 되면 원하지 않게 리밸런스가 일어나기도 한다  
반면에 이 시간을 너무 길게 설정하면 리밸런스가 일어날 가능성은 줄지만, 오류를 감지하는데 오래 걸릴 수 있다  

#### heartbeat.interval.ms
컨슈머는 자신이 정상 동작중이라는 것을 알리기위해 브로커에게 주기적으로 heartbeat 를 보낸다  
heartbeat 는 poll() 메서드를 사용해 보내며, 실제 데이터를 읽어가지는 않는다  
이 값은 `session.timeout.ms` 시간보다 낮아야 한다(일반적으로 1/3 정도로 설정)  

#### max.poll.records
poll 요청에 대한 최대 레코드 수 이다  

#### max.poll.interval.ms
컨슈머가 계속해서 heartbeat 만 보내고 데이터를 가져가지 않는 경우가 있을수도 있다(어떠한 장애로 인하여)  
이러한 경우 컨슈머가 무한정 해당 파티션을 점유할 수 없도록, 지정한 시간만큼 실제 poll 을 요청하지 않으면 장애라고 판단하고 컨슈머 그룹에서 제외한다  